\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{courier}
\usepackage{multicol}
\usepackage{float}
\usepackage{graphicx}
\usepackage{tikz}
\restylefloat{table}
\DeclareGraphicsExtensions{.jpg}
\definecolor{mygray}{rgb}{0.94,0.94,0.94}

\lstset{ %
	backgroundcolor=\color{mygray},
    basicstyle=\footnotesize}
\author{Michael Nguyen, Prateek Sinha, Yuchen Zeng, and Eli Bogom-Shanon }
\title{Civ}

\begin{document}
\maketitle
\section{Introduction}
\subsection{What is Civ}
Civ is a new language implemented by the authors as an academic project for Programming Languages and Translators class (COMS W4115) taught by Prof. Stephen A. Edwards.
\subsection{Motivation}
C is one of the most used languages in the world, however it is hard for the novice programmers to just learn the basic programming concepts given the myriad number of features and concepts associated with C. Thus for our project we decided to implement a subset of C which would provide our users an easy programming environment that enables them to quickly grasp the fundamental programming concepts such as control structures, data types, functions, etc.
\subsection{Differences from C}
\begin{description}
    \item[Dynamic Arrays] - All arrays are dynamic by default, all done by backend malloc. Memory is freed and reallocated automatically.
    \item[Automatic Garbage Collection] - All mallocs are automally deallocated at the exit of a lexical scope. With these two points, memory management can largely be abstracted away from the user.
    \item[No pointers or addresses] - Given these two differences, Civ has no usage of pointers or references, thus providing a level of safety for the beginning user.
\end{description}

\section{Language Tutorial}
\subsection{Basics}
Civ is a subset of C which means that it follows the same syntax as that of C language and it supports  multiple features of C. 

Civ programs are saved with ".mc" extension. The compiler takes this file and outputs C code provided there are no syntactical or semantic errors. This C code then can be saved to a output file and executed through GCC. 

\subsection{Keywords and Data Types}
Civ has the following types:
\begin{description}
    \item[int] - signed integers.
    \item[float] - signed floats, including scientific notation (e.g. 3.e-15).
    \item[char] - standard ASCII characters, to include escape characters with '\'.
    \item[String] - strings are supported, though they immediately get converted to character arrays. 
\end{description}

\subsection{Examples}
\paragraph{Hello World}

\subsection{Compiling and Executing Civ}
In-order to compile and execute a Civ program the user needs to save the file with a ".mc" extension within the root directory of where the Civ compiler is stored, e.g. 
/home/user/code/civ/test/civprogram.mc
From there:
\begin{description}
    \item[1] \begin{verbatim}./civ --gcc < \[path or regex\] > output.c \end{verbatim}
    \item[] civ takes in a regex or a path, meaning it can compile multiple files at once. This is a byproduct of its original use as a test suite, but works just as well. This will compile the output file through gcc and create an executable where the source code is, e.g.
\begin{verbatim}
    /home/user/code/civ/test/civprogram.exe
\end{verbatim}
    \item[2] From there, just execute the file, e.g.:
\begin{verbatim}
    ./home/user/code/civ/civprogram.exe
\end{verbatim}
\end{description}

\section{Language Reference Manual}
\subsection{Preface}
This language reference manual describes the Civ language, developed by, Michael Nguyen, Prateek Sinha, Yuchen Zeng, and Eli Bogom- Shanon for Stephen Edwards's Programming Languages and Translators class (W4115).
Given its similarity to the C language, this document closely follows an organizational precedent set by Brian Kernighan and Dennis Ritchie in their "The C Programming Language."


\subsection{Introduction}
Civ is a computer language based on C. However are a few major differences between Civ and C. Civ has no explicit usage of pointers in its syntax. This means that the symbol * is only used in Civ for exponentiation and multiplication functions. Because there are no explicit pointers, there are also no explicit references using the \& symbol. Civ also provides dynamically allocated arrays, whereas in C, native arrays are static in nature. While arrays created dynamically in C requires explicit calls to memory allocation functions, as well as the associated free calls, Civ handles memory allocation and garbage collection automatically. Civ is meant to provide a simplified version of C that enables a user to quickly grasp fundamental programming concepts, such as control structures, data types, functions, etc., without having to learn pointer arithmetic or memory management.

 
\subsection{Lexical Conventions}
There are five kinds of tokens: identifiers, keywords, strings, expression operators, and other separators. In general blanks, tabs, newlines, and comments as described below are ignored except as they serve to separate tokens. At least one of these characters is required to separate otherwise adjacent identifiers, constants, and certain operator-pairs. 

\paragraph{Comments}
Comments are styled after the C multiline comments. A comment block begins with the characters /* and is terminated with */ . Civ does not provide nested comment support.
\begin{verbatim}
/* This is a comment in Civ */
/*
This is a multiline comment in Civ
*/
// Unlike C, this is not a valid comment
\end{verbatim}

\paragraph{Identifers}
In Civ, an identifier is an alphanumeric sequence. Upper case and lower case letters are considered to be different in Civ. 

\paragraph{Keywords}
The following identifiers are reserved for the use as keywords, and may not be used otherwise:
\begin{itemize}
\item int
\item float
\item char
\item true
\item false
\item String
\item if
\item else
\item for
\item while
\item break
\item continue
\item return
\item void
\end{itemize}
There are also a few built in functions: $printf$ and $maxArrayElement$. Printf() is used in the same manner as the standard I/O function in C.
maxArrayElement is declared as

\begin{verbatim}
    int maxArrayElement(type array[]);
\end{verbatim}

Type can be int, char, or float. The function returns the number of elements between the start of the array and the last element in use - that is, the effective size of the array in number of elements.

\paragraph{Constants}
There are several kinds of constants, as follows:

\subparagraph{Integer constants}
An integer constant is a sequence of digits.

\subparagraph{Character constants}
A character constant is 1 character enclosed in single quotes '' ? ''.  Within a character constant a single
quote must be preceded by a back-slash ''\''. Certain non-graphic characters, and ''\'' itself, may be escaped by preceding them with a '\'.

\subparagraph{Floating constants}
A floating constant consists of an integer part, a decimal point, a fraction part, an e, and an integer exponent. The integer and fraction parts both consist of a sequence of digits. Either the integer part or the fraction part (not both) may be missing; either the decimal point or the e and the exponent (not both) may be missing.

\subparagraph{Strings}
A string is a sequence of characters surrounded by double quotes '' " ''. A string has the type array-of-characters (see below) and refers to an area of storage initialized with the given characters.  The compiler places a null byte ( \\0 ) at the end of each string so that programs which scan the string can find its end.

\subsection{Types}
Civ supports three fundamental types of objects: characters, integers, and floating-point numbers.
\begin{description}
    \item[Characters] (declared, and hereinafter called, char) are chosen from the ASCII set.
    \item[Integers] (int) are represented in 16-bit 2's complement notation.
    \item[Floating points] (float) quantities have magnitude in the range approximately 10$\pm$38 or 0; their precision is 24 bits or about seven decimal digits.
\end{description}
Besides the three fundamental types there are classes of derived types constructed from the fundamental types in the following ways:
\begin{description}
\item[Arrays] of objects.
\item[Strings] arrays of chars
\item[Functions] which return objects of a given type. 
\end{description}

\paragraph{Conversions}

Unlike C, Civ generally does not allow type conversions, either implicitly or explicitly. The programmer is expected to treat a given object as the same type for the duration of the object's lifetime.

\subsection{Objects and lvalues}
An object is a manipulatable region of storage; an lvalue is an expression referring to an object. An obvious example of an lvalue expression is an identifier. The name ''lvalue'' comes from the assignment expression ''E1 = E2'' in which the left operand E1 must be an lvalue expression.
The discussion of each operator below indicates whether it expects lvalue operands and whether it yields an lvalue.

\subsection{Expressions}
The precedence of expression operators is the same as the order of the major subsections of this section (highest precedence first). Within each subsection, the operators have the same precedence. Left- or right-associativity is specified in each subsection for the operators discussed therein. The precedence and associativity of all the expression operators is summarized at the end of this section. Otherwise the order of evaluation of expressions is undefined.

\paragraph{Primary Expressions}
Primary expressions involving subscripting and function calls group left to right.
\begin{description}
\item[identifier] An identifier is a primary expression, provided it has been suitably declared as discussed below. Its type is specified by its declaration.
\item[constant]
A decimal or floating constant is a primary expression. Its type is int in the first case and double in the second.
\item[string]
A string is a primary expression. Its type is ''array of char''.
\item[( expression )]
A parenthesized expression is a primary expression whose type and value are identical to those of the unadorned expression. The presence of parentheses does not affect whether the expression is an lvalue.
\item[primary-expression ( expression-list)]
A function call is a primary expression followed by parentheses containing a possibly empty, comma-separated list of expressions which constitute the actual arguments to the function. The primary expression must be of type ''function returning . . .'', and the result of the function call is of type ''. . . ''. In preparing for the call to a function, a copy is made of each actual parameter; thus, almost all argument-passing in Civ is by value. However, the array type in Civ is actually passed by pointer in the compiled target C code. While this is not directly shown to the user, it should be noted that in Civ, primitive data types are passed by value, while the aggregate type array is passed by reference. 
\end{description}

\paragraph{Unary Operators}
Expressions with unary operators gruop right to left.
\begin{description}
\item[- expression]
The result is the negative of the expression, and has the same type. The type of the expression must be int or float.
\item[! expression]
The result of the logical negation operator ! is 1 if the value of the expression is 0, 0 if the value of the expression is non-zero. The type of the result is int. This operator is applicable only to ints.
\end{description}

\paragraph{Multiplicative Operators}
The multiplicative operators *, /, and \% group left-to-right.
\begin{description}
\item[expression * expression]
The binary * operator indicates multiplication. If both operands are of type int, the result is int; if both are type float, the result is float. If one is int and the other is float, the former is converted to float and float is returned.
\item[expression / expression]
The binary / operator indicates division. The same type considerations as for multiplication apply.
\item[expression \% expression]
The binary \% operator yields the remainder from the division of the first expression by the second. Both operands be int, and the result is int.
\end{description}

\paragraph{Additive Operators}
The additive operators + and - group left-to-right.
\begin{description}
\item[expression + expression]
The result is the sum of the expressions. If both operands are int, the result is int. If both are float, the result is float. If one is int and one is float, the former is converted to float and the result is float. No other type combinations are allowed.
\item[expression - expression]
The result is the difference of the operands. The same type considerations as for + apply.
\end{description}

\paragraph{Relational operators}
The relational operators group left-to-right, but this fact is not very useful; ''$a<b<c$'' does not mean what it seems to.
\begin{description}
\item[]expression < expression
\item[]expression > expression
\item[]expression <= expression
\item[]expression >= expression
The operators < (less than), > (greater than), <= (less than or equal to) and >= (greater than or equal to) all yield 0 if the specified relation is false and 1 if it is true. Operand conversion is exactly the same as for the +.
\end{description}
\paragraph{Equality operators}
\begin{description}
\item[expression == expression]
\item[expression != expression]
The == (equal to) and the != (not equal to) operators are exactly analogous to the relational operators except for their lower precedence. (Thus ''a<b == c<d'' is 1 whenever a<b and c<d have the same truth-value).
\end{description}
\paragraph{expression \&\& expression}
The \&\& operator returns 1 if both its operands are non-zero, 0 otherwise. Unlike \&, \&\& guarantees left-to-right evaluation. The operands need not have the same type, but each must have one of the fundamental types.

\paragraph{6.8 expression $||$ expression}
The $||$ operator returns 1 if either of its operands is non-zero, and 0 otherwise. Unlike $|$ , $||$ guarantees left-to-right evaluation. The operands need not have the same type, but each must have one of the fundamental types.

\paragraph{Assignment Operators}
There are a number of assignment operators, all of which group right-to-left. All require an lvalue as their left operand, and the type of an assignment expression is that of its left operand. The value is the value stored in the left operand after the assignment has taken place.

\subsection{Declarations}
Declarations are used within function definitions to specify the interpretation which C gives to each identifier; they do not necessarily reserve storage associated with the identifier. Declarations have the form
\begin{verbatim}
    declaration:
        type-specifier declarator-list;
\end{verbatim}
The declarators in the declarator-list contain the identifiers being declared. The type-specifier consists of one type-specifier.

\paragraph{Type specifiers}
The type-specifiers are:
\begin{verbatim}
    type-specifier:
        int
        char
        float
        void
\end{verbatim}
A type-specifier must be included in each declaration. The void type can only be declared as the return type of a function.

\paragraph{Declarators}
The declarator-list appearing in a declaration is a comma-separated sequence of declarators.
\begin{verbatim}
    declarator-list:
        declarator
        declarator , declarator-list
\end{verbatim}
The specifiers in the declaration indicate the type of the objects to which the declarators refer. Declarators have the syntax:
\begin{verbatim}
    declarator:
        identifier
        declarator ( )
        declarator [ constant-expression ]
        ( declarator )
\end{verbatim}
The grouping in this definition is the same as in expressions

\paragraph{Meaning of Declarators}
Each declarator is taken to be an assertion that when a construction of the same form as the declarator appears in an expression, it yields an object of the indicated type. Each declarator contains exactly one identifier; it is this identifier that is declared. If an unadorned identifier appears as a declarator, then it has the type indicated by the specifier heading the declaration.

If a declarator has the form
\begin{verbatim}
    D( )
\end{verbatim}
then the contained identifier has the type ''function returning ...'', where ''. . . '' is the type which the identifier would have had if the declarator had been simply D.
\begin{verbatim}
    D[ ]
\end{verbatim}
It is valid to use this declarator without a constant expression. Such a declarator makes the contained identifier have type ''array.'' If the unadorned declarator D would specify a nonarray of type ''. . .'', then the declarator ''$D[ ]$'' yields a 1-dimensional dynamic array of objects of type ''. . .''. If the unadorned declarator D would specify an n-dimensional array with rank $i_1 , i_2 , ... , i_n$, then the declarator ''$D[ i_n+1 ]$'' yields an (n +1)-dimensional array with rank $i_1 , i_2 , ... , i_n , i_{n+1}$.

An array may be constructed from one of the basic types.

Finally, parentheses in declarators do not alter the type of the contained identifier except insofar as they alter the binding of the components of the declarator.

Not all the possibilities allowed by the syntax above are actually permitted. The restrictions are as follows: functions may not return functions; there are also no arrays of functions. Here, Civ is slightly more restrictive than C, as in C some of these restrictions may be circumvented through use of pointers.


\subsection{Statements}
Except as indicated, statements are executed in sequence.

\paragraph{Expression statement}
Most statements are expression statements, which have the form:
\begin{verbatim}
    expression ;
\end{verbatim}
Usually expression statements are assignments or function calls.

\paragraph{Compound statement}
So that several statements can be used where one is expected, the compound statement is provided:
\begin{verbatim}
    compound-statement:
        { statement-list }

    statement-list:
        statement
        statement statement-list
\end{verbatim}

\paragraph{Conditional statement}
The two forms of the conditional statement are:
\begin{verbatim}
    if ( expression ) statement
    if ( expression ) statement else statement
\end{verbatim}
In both cases the expression is evaluated and if it is non-zero, the first sub-statement is executed. In the second case, the second sub-statement is executed if the expression is 0. As usual the ''else'' ambiguity is resolved by connecting an else with the last encountered else-less if.

\paragraph{While statement}
The while statement has the form:
\begin{verbatim}
    while ( expression ) statement
\end{verbatim}
The sub-statement is executed repeatedly so long as the value of the expression remains non-zero. The test takes place before each execution of the statement.

\paragraph{For statement}
The for statement has the form:
\begin{verbatim}
    for ( expression-1 ; expression-2 ; expression-3 ) statement
\end{verbatim}
This statement is equivalent to:
\begin{verbatim}
    expression-1;
    while ( expression-2 ) {
        statement
        expression-3 ;
    }
\end{verbatim}
Thus the first expression specifies initialization for the loop; the second specifies a test, made before each iteration, such that the loop is exited when the expression becomes 0; the third expression typically specifies an incrementation which is performed after each iteration.

\paragraph{Break statement}
The statement
\begin{verbatim}
    break ;
\end{verbatim}
causes termination of the smallest enclosing while, do, or for statement; control passes to the statement
following the terminated statement.

\paragraph{Continue statement}
The statement
\begin{verbatim}
    continue ;
\end{verbatim}
causes control to pass to the loop-continuation portion of the smallest enclosing while, do, or for statement; that is to the end of the loop.

\paragraph{Return statement}
A function returns to its caller by means of the return statement, which has one of the forms
\begin{verbatim}
    return ;
    return ( expression ) ;
\end{verbatim}
In the first case no value is returned. In the second case, the value of the expression is returned to the caller of the function. The expression must evaluate to the type of the function in which it appears.
Flowing off the end of a function is equivalent to a return with no returned value. There are some exceptions to this. A return expression cannot of type element-of-array. 
\begin{verbatim}
    return( a[0] );
\end{verbatim}
is not a valid statement in Civ. The value must be assigned outside of the return statement, then passed in.

\subsection{Scope rules}
Civ, unlike C, has a strictly lexical scope. Civ is a block-structured language. The lexical scope of names declared at the head of functions (either as formal parameters or in the declarations heading the statements constituting the function itself) is the body of the function. It is an error to re-declare identifiers already declared in the current context, unless the new declaration specifies the same type and storage class as already possessed by the identifiers.

\subsection{Arrays}
Every time an identifier of array type appears in an expression, it is treated as array-of-(type at declaration). Because of this, arrays are not lvalues. The subscript operator $[ ]$ is interpreted in such a way that if E1 is an array and E2 an integer, then E1$[$E2$]$ refers to the E2-th member of E1. A consistent rule is followed in the case of multi-dimensional arrays. If E is an n-dimensional array of rank $i , j , ... ,k$, then E appearing in an expression evaluates from array-of-array of (n-1)-dimensional array with rank j , ... ,k to the type held in dimension k. 

\subsection{Example code}
The following code executed a bubblesort on an array of integers. It showcases the use of the dynamic array datatype in Civ, an shows a brief example of using the formatted print option, which is modeled after C's own printf().
\begin{verbatim}
void bubblesort(int t[]){
    int i,j;
    int n;
    n = maxArrayElement(t) + 1;
    for(i = 1; i < n; i = i + 1){
        for(j = 0; j < n - i - 1; j = j + 1){
            if(t[j] > t[j + 1]){
                int a = t[j];
                int b = t[j + 1];
                int temp = t[j];
                t[j] = t[j + 1];
                t[j + 1] = temp;
                printf("SWAPPING: %d %d \n",a,b);
            }   
        }    
    }
return;
}

void main(){
    printf("Bubblesort \n");
    int g[];
    int z;
    for(z = 10; z > 0; z = z - 1){
    g[10 - z] = z;
    }
    for(z = 0; z < 10; z = z + 1){ 
    int temp = g[z];
    printf("%d ", temp);
    }
    bubblesort(g);
    printf("Sorted! \n");
    for(z = 0; z < 10; z = z + 1){
        int temp = g[z];
        printf("%d \n", temp);
    }
    return;
}
\end{verbatim}








\section{Project Plan}
\subsection{Planning, Development, and Testing}
\paragraph{Planning} We started with weekly meetings to discuss the features we wanted to implement in our language. At the beginning we had the idea of implementing a distributed language with the target of achieving the functionality of Map Reduce. However, since none of the team members had in-depth knowledge of the concept, we realized that it would be very difficult to come up with the solutions to the problems we would be facing while development thus, we consulted the instructor and by the end of September we started working towards the idea of implementing Civ.

We kept the same schedule, meeting every week on Sunday to discuss and kept meeting our TA Vaibhav on a regular basis to resolve various issues that came up while implementing Civ.


\paragraph{Development}
For development we used Git as our version control system and checked out work into a remote repository on GitHub. Just by happenstance, we ended up adopting a wave strategy of implementation, as we weren't sure how to allocate our workload, and our project leader had medical issues. The first wave was Mike, who wanted to implement as much of a working language as possible, even if it meant C to C. He developed the grammar, ast generation, and code generation the first week of December. Yuchen was the second wave who implemented the semantic analyzer and the SAST, and Mike worked with him to merge it into the pipeline. Eli came in as third wave and implemented the core pieces of our language, with the dynamic arrays and garbage collection during the last week. During this entire process, eveyone was either writing test cases, building auxiliary tools, or helping any way they can to support the current wave.

\paragraph{Testing}
A test suite was written about halfway through that allowed rapid testing and feedback of our code. It supported both expected passing and expected failing cases to highlight false positives or true negatives, and allowed quick isolation of where the errors were. This test suite later turned into an extension of the compiler itself.


\subsection{Style Guide}
Our overall guiding point was to minimize code redundancy, so both Mike and Yuchen wrote a lot of auxiliary functions (especially for code generation) that converted variou stypes into strings or other types depending on the sitution. The grammar was also meant to minimize redundancy, and utilized a lot of recursion like most grammars do to account for strange cases.

\subsection{Project Timeline and Log}
\begin{description}
\item[September - November] We had a lot of talking and very little coding done through these months. By the end of it, we had a rough idea of the language, but we had no idea how to go about actually implementing it, especially regarding dynamic arrays or garbage collection.
\item[December] This is where development began.

\small
\begin{verbatim}

12/16/14
Yuchen/Eli -
* Re-implemented dynamic arrays at the lsat minute

Prateek -
* Finished slides/presentation and report

12/15/14
Mike -
* Fixed float parsing
* Test suite now fully gcc's
* Added in continue/break
* Varchaining fully implemented
* Fixed some code generation (For/Call/If/While)

Yuchen/Eli -
* Fully implemented and tested dynamic arrays/garbage collection

12/14/14
Mike - 
* Strings are in e.g. char x[] = "test"; -- see SAssign in ast.ml
* String declarations in char x[] = now string * string * string list
* For loop's last argument is now stmt list as opposed to stmt
* If's last argument is now stmt list as opposed to stmt
* Escape characters are in treated as chars of max size 2.
* Variable declaration chaining in e.g. int x,y; - see VDecllist in ast.ml
* INCR/DECR added under expressions - Will add a type under EXPR for it later

Yuchen -
* Dynamic Arrays are in
* Add string in sast, semantic and ccompilesast
* Fixed a few test cases

12/13/14
Mike/Yuchen -
* Arrays now have their own ID type
* Arrays can be used to describe formal arguments
* Changed all iliterals into expressions that hopefully get resolved
* Added in GCC to test suite

Yuchen/Eli
* Code Generation of Static/Dynamic Arrays

Eli -
* Added in more testing of the dynamic array header file

12/12/14
Mike -
* Consolidated pipeline
* Fixed all tests cases that use single line comments
* Added more static array test cases
* Added more features to test suite
* Static arrays fully functional
* Dynamic array declarations in

Eli -
* Added set of test cases for dynamic arrays
* Single dynamic array C header up
* Prototype for C automatic garbage collction up

Yuchen -
* Consolidated pipeline
* Add 'Printlist' in sast
* Add semantic checking for static array declaration
* Worked more miracles

Prateek -
* Doubled test cases to ~100
* Reorganized all test cases into PASS/-feature and FAIL/-feature folders to test individual features

12/11/14
Eli -
* Split up all test cases into incremental

Yuchen -
* Worked miracles in semantic analyzer
* Add 'Array' and 'Print' in sast
* Make the compile using sast work

12/10/14
Mike -
* Redid tester = fully operational pending further features
* I hate recursive data types - can't figure out how to do array
* Printf now works with (str,args);

Yuchen
* Add return type checking
* Write the function convert program in ast to program in sast and merge sast into the pipeline

12/9/14
Eli -
* Added more tests cases to account for arrays
* Progress on dynamic arrays and automatic garbage collection

Yuchen -
* Most problems about scope are solved and tested (Scope for 'While' and 'For', scope for global environment, scope for multi functions, scope for formals)
* Add test cases for scope and multi functions

###12/8/14###
Yuchen -
* Problem with 'call' is solved and tested. Function's name and type, arguments' number and types are checked.
* Add semantic checking and ast-sast converting for 'Call', 'Return'


12/6/14
Mike -
* Nested Arrays are in

Eli -
* Strategy for implementing pointerless C done

Yuchen - 
* Worked towards putting SAST between AST -> CCompile

Prateek - 
* Rewrote python test script

12/6/14
Yuchen - 
* Add semantic checking and ast-sast converting for 'While', 'For', 'VDecl' 
  UNTESTED - semantic checking and ast-sast converting for 'While', 'For'
* Add semantic checking: if there is id confict when initialing new vairable in both 'VDecl' and 'NAssign'

12/5/14
Yuchen -
* Added Types.ml, Sast.ml
* UNTESTED - Began work on Semantic; implemented: utility functions for AST traversal, scoping environments, equality tests, type checking, type requirements, environmeny var/func checks

12/4/14
Mike -
* IN PROGRESS - Added in array optionals that come after ID Token
* Adjusted TYPE ID ASSIGN expr to statements. CONSIDER MOVING BACK TO EXPR FOR CHAINED.
* Global declarations are now ALWAYS TYPE ID ASSIGN LITERAL.
* Arithmetic operations working as expected
* UNTESTED - float literals - currently viewed as strings
* UNTESTED/OPTIONAL - Added break,const,continue,extern,float,static 
* UNTESTED - Added increment/decrement, NOT ADDED TO GRAMMAR YET
* More test cases

Eli -
* Created more in-depth test cases 

Prateek -
* Added python test script

12/3/14
Mike -
* Var Declaration can occur anywhere, e.g. int x; now works like c99 standard
* All grammar rules accounted for with two conflicts
* Formal arguments take type now
* Print accounted for
* Added three print test cases in tests/ps/
* Global variable INITIALIZATION in (seems useless)
* UNTESTED - Strings added to lexer/parser/compiler
* UNTESTED - Chars added, same as strings

12/2/14
Mike -  
* Code generation up and running!
* Basic formatting to do basic C code up.
* UNTESTED - Added print statement to scanner and grammar
* UNTESTED - Differentiated new variable declaration AND assignment
* Removed all old code e.g. bytecode/compile (now ccompile), etc.
* Removed all old test cases and modified Makefile for new environment


12/1/14
Mike -  
* Started over from scratch
* Added in type declarations for functions
* Added in variable declaration and assignment of expression
* Added ccompile/ccode.ml to be used for actual compilation
* Microc now has a -C flag that is used for actual ccompile.translate
* Codegeneration has begun - need to adjust formatting and account for type_decl string formatting
* Mikhail helped
\end{verbatim}
\normal
\end{description}

\subsection{Software Environment}
\begin{description}
\item[Operating Systems] Windows, Linux, Mac OS
\item[Core Language] OCaml 4.01.0
\item[Scripting] Python 2.7
\item[C Compiler] GCC 4.6
\end{description}
\subsection{Roles and Responsibilities}
\begin{description}
\item[Eli Bogom-Shanon] - Core Language Designer
\item[Michael Nguyen] - Project Lead, Environment/Git Master, Test Suite Developer, Grammar Developer
\item[Prateek Sinha] - Documentation and Test Case maker
\item[Yuchen Zeng] - Core Developer, Semantic Analysis and Code Generation Developer
\end{description}

\section{Architecture}
Civ uses a textbook setup. The sequence is as follows:
\begin{description}
    \item[Scanner] - The scanner tokenizes an input string into a set of tokens. Any substring that isn't recognized implies it is not a valid program, so the program is immediately rejected.
    \item[Parser] - The parser takes a set of tokens and builds an Abstract Syntax Tree from it using pre-defined context free grammar.
    \item[Semantic Analyzer] - The analyzer takes an AST and does semantic checking to make sure the abstract syntax tree 'makes sense'. In our case, it outputs near-C equivalent AST.
    \item[Code Generator/Compiler] - This takes in the checked AST and outputs the actual C code, using a roughly one to one mapping.
\end{description} 
    \begin{figure}
    \begin{tikzpicture}

    \node (p1) at ( 0, 0) {Program}; 
    \node (p2) at ( 3, 0) {Tokens};
    \node (p3) at ( 6, 0) {AST};
    \node (p4) at ( 6,-3) {Semantically Checked AST};
    \node (p5) at ( 4,-6) {C Code};

    \begin{scope}[every path/.style={->}]
       \draw (p1) -- (p2) { Scanner };
       \draw (p2) -- (p3) { Parser }; 
       \draw (p3) -- (p4) { Semantic Checking }; 
       \draw (p4) -- (p5) { Code Generation};
    \end{scope}  


    \end{tikzpicture}
    \end{figure}
\section{Testing}

B. W. Kernighan and D. M. Ritchie, The C Programming Language, Prentice-Hall, Englewood Cliffs New Jersey, 1978.

\end{document}
